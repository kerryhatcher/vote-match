<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title }}</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>

    <!-- Leaflet.markercluster CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/MarkerCluster.css"
          crossorigin="anonymous"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/MarkerCluster.Default.css"
          crossorigin="anonymous"/>

    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }

        #map {
            width: 100%;
            height: 100vh;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            font-size: 18px;
            color: #333;
        }

        .loading-overlay.hidden {
            display: none;
        }

        .info {
            padding: 6px 8px;
            font: 14px/16px Arial, Helvetica, sans-serif;
            background: white;
            background: rgba(255,255,255,0.95);
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            border-radius: 5px;
        }

        .info h4 {
            margin: 0 0 5px;
            color: #333;
            font-size: 16px;
        }

        .info .count {
            font-size: 18px;
            font-weight: bold;
            color: #4169E1;
            margin: 5px 0;
        }

        .info .credit {
            font-size: 11px;
            color: #666;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #ddd;
            line-height: 1.4;
        }

        .info .credit a {
            color: #4169E1;
            text-decoration: none;
        }

        .info .credit a:hover {
            text-decoration: underline;
        }

        .legend {
            line-height: 22px;
            color: #555;
            background: white;
            background: rgba(255,255,255,0.95);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            max-height: 350px;
            overflow-y: auto;
        }

        .legend h4 {
            margin: 0 0 8px;
            font-size: 14px;
            font-weight: bold;
            color: #333;
        }

        .legend i {
            width: 18px;
            height: 18px;
            float: left;
            margin-right: 8px;
            opacity: 0.7;
            border: 1px solid #333;
        }

        .legend .circle {
            border-radius: 50%;
        }

        /* Collapsible legend styles */
        .legend-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
            margin-bottom: 8px;
        }

        .legend-header h4 {
            margin: 0;
            flex: 1;
        }

        .legend-toggle {
            background: none;
            border: none;
            font-size: 16px;
            cursor: pointer;
            padding: 4px 8px;
            margin-left: 8px;
            color: #333;
            min-width: 44px;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .legend-toggle:hover {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 3px;
        }

        .legend-content {
            max-height: 350px;
            overflow-y: auto;
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
        }

        .legend.collapsed .legend-content {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
        }

        .legend.collapsed .legend-header {
            margin-bottom: 0;
        }

        /* Mobile: legends start collapsed by default */
        @media (max-width: 767px) {
            .legend {
                max-height: none;
            }

            /* Increase bottom spacing for mobile browser UI */
            .leaflet-bottom.leaflet-center {
                bottom: 80px !important; /* Move up from 10px to clear browser UI */
            }

            /* Ensure left/right bottom controls are also visible */
            .leaflet-bottom.leaflet-left,
            .leaflet-bottom.leaflet-right {
                bottom: 70px !important; /* Move legends up from default position */
            }

            /* Reduce legend max-width on narrow screens */
            .legend {
                max-width: 180px;
                font-size: 11px;
            }
        }

        .leaflet-popup-content-wrapper {
            border-radius: 5px;
        }

        .leaflet-popup-content {
            margin: 13px 19px;
            line-height: 1.4;
        }

        .popup-header {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
        }

        .popup-section {
            margin-bottom: 8px;
        }

        .popup-label {
            font-weight: bold;
            color: #666;
        }

        .mismatch-warning {
            background: #fff3cd;
            border: 1px solid #ffc107;
            padding: 6px;
            margin: 8px 0;
            border-radius: 3px;
            color: #856404;
        }

        .match-ok {
            background: #d4edda;
            border: 1px solid #28a745;
            padding: 6px;
            margin: 8px 0;
            border-radius: 3px;
            color: #155724;
        }

        .leaflet-top.leaflet-center {
            left: 50%;
            transform: translateX(-50%);
            top: 10px;
        }

        .leaflet-bottom.leaflet-center {
            left: 50%;
            transform: translateX(-50%);
            bottom: 10px;
        }

        /* Spiderfy leg styling */
        .leaflet-cluster-spider-leg {
            stroke-width: 2;
            stroke-opacity: 0.6;
            fill: none;
        }

        /* Cluster icons */
        .marker-cluster {
            background-clip: padding-box;
            border-radius: 50%;
        }

        .marker-cluster div {
            width: 30px;
            height: 30px;
            margin-left: 5px;
            margin-top: 5px;
            text-align: center;
            border-radius: 50%;
            font: 12px "Helvetica Neue", Arial, Helvetica, sans-serif;
            font-weight: bold;
            color: white;
        }

        .marker-cluster span {
            line-height: 30px;
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loading">
        <div>Loading map data...</div>
    </div>
    <div id="map"></div>

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <!-- Leaflet.markercluster JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/leaflet.markercluster.js"
            crossorigin="anonymous"></script>

    <script>
        // HTML escaping function for XSS protection
        function escapeHtml(text) {
            if (text === null || text === undefined) {
                return '';
            }
            const div = document.createElement('div');
            div.textContent = String(text);
            return div.innerHTML;
        }

        // Color palette with enough distinct colors for any number of districts
        const colorPalette = [
            '#377eb8', '#e41a1c', '#4daf4a', '#ff7f00', '#984ea3',
            '#a65628', '#f781bf', '#1b9e77', '#d95f02', '#7570b3',
            '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666',
        ];

        // Normalize district ID by stripping leading zeros
        function normalizeId(id) {
            return String(id).replace(/^0+/, '') || '0';
        }

        // Dynamic color map built once data is loaded
        const colorMap = {};

        function buildColorMap(votersData, districtsData) {
            const ids = new Set();
            if (districtsData && districtsData.features) {
                districtsData.features.forEach(function(f) {
                    if (f.properties.district_id) ids.add(normalizeId(f.properties.district_id));
                });
            }
            if (votersData && votersData.features) {
                votersData.features.forEach(function(f) {
                    if (f.properties.registered_district) ids.add(normalizeId(f.properties.registered_district));
                });
            }
            var sorted = Array.from(ids).sort(function(a, b) {
                var na = parseInt(a), nb = parseInt(b);
                if (!isNaN(na) && !isNaN(nb)) return na - nb;
                return a.localeCompare(b);
            });
            sorted.forEach(function(id, i) {
                colorMap[id] = colorPalette[i % colorPalette.length];
            });
        }

        // Privacy setting from server
        const redactPii = {{ redact_pii }};

        function getColor(district) {
            return colorMap[normalizeId(district)] || '#999999';
        }

        function getVoterColor(district) {
            return getColor(district);
        }

        function getDistrictColor(district) {
            return getColor(district);
        }

        const map = L.map('map');

        // Create custom center positions for controls
        map._controlCorners['topcenter'] = L.DomUtil.create('div', 'leaflet-top leaflet-center', map._controlContainer);
        map._controlCorners['bottomcenter'] = L.DomUtil.create('div', 'leaflet-bottom leaflet-center', map._controlContainer);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            maxZoom: 19
        }).addTo(map);

        function createVoterPopup(properties) {
            const p = properties;

            if (redactPii) {
                // Privacy mode: minimal popup with district and data quality info only
                let html = '<div class="popup-header">Voter Location</div>';
                html += '<div class="popup-section">';
                html += '<span class="popup-label">Registered District:</span> ' + escapeHtml(p.registered_district || 'Unknown') + '<br>';
                html += '<span class="popup-label">Spatial District:</span> ' + escapeHtml(p.spatial_district_id || 'Unknown') + '<br>';
                html += '</div>';

                if (p.district_mismatch) {
                    html += '<div class="mismatch-warning">⚠️ <strong>District Mismatch!</strong><br>Registered in District ' + escapeHtml(p.registered_district) + ' but located in District ' + escapeHtml(p.spatial_district_id) + '</div>';
                } else if (p.spatial_district_id && p.registered_district) {
                    html += '<div class="match-ok">✓ Districts match</div>';
                }

                if (p.geocode_status) {
                    html += '<div class="popup-section">';
                    html += '<span class="popup-label">Geocode Quality:</span> ' + escapeHtml(p.geocode_status);
                    if (p.geocode_match_type) html += ' (' + escapeHtml(p.geocode_match_type) + ')';
                    html += '<br></div>';
                }

                return html;
            } else {
                // Original behavior: full voter details
                let html = '<div class="popup-header">' + escapeHtml(p.full_name) + '</div>';
                if (p.voter_registration_number) {
                    html += '<div class="popup-section"><span class="popup-label">Registration #:</span> ' + escapeHtml(p.voter_registration_number) + '<br></div>';
                }
                html += '<div class="popup-section"><span class="popup-label">Address:</span> ' + escapeHtml(p.street_address) + '<br>';
                if (p.residence_city) html += escapeHtml(p.residence_city) + '<br>';
                html += '</div>';
                html += '<div class="popup-section"><span class="popup-label">Registered District:</span> ' + escapeHtml(p.registered_district || 'Unknown') + '<br>';
                html += '<span class="popup-label">Spatial District:</span> ' + escapeHtml(p.spatial_district_id || 'Unknown') + '<br></div>';
                if (p.district_mismatch) {
                    html += '<div class="mismatch-warning">⚠️ <strong>District Mismatch!</strong><br>Voter is registered in District ' + escapeHtml(p.registered_district) + ' but located in District ' + escapeHtml(p.spatial_district_id) + '</div>';
                } else if (p.spatial_district_id && p.registered_district) {
                    html += '<div class="match-ok">✓ Districts match</div>';
                }
                if (p.geocode_status) {
                    html += '<div class="popup-section"><span class="popup-label">Geocode Status:</span> ' + escapeHtml(p.geocode_status) + '<br>';
                    if (p.geocode_match_type) html += '<span class="popup-label">Match Type:</span> ' + escapeHtml(p.geocode_match_type) + '<br>';
                    html += '</div>';
                }
                return html;
            }
        }

        function createDistrictPopup(properties) {
            const p = properties;
            let html = '<div class="popup-header">District ' + escapeHtml(p.district_id) + '</div>';
            if (p.district_name) html += '<div class="popup-section">' + escapeHtml(p.district_name) + '<br></div>';
            if (p.voter_count !== null && p.voter_count !== undefined) html += '<div class="popup-section"><span class="popup-label">Voters in District:</span> ' + escapeHtml(p.voter_count.toLocaleString('en-US')) + '<br></div>';

            // Add mismatch counts if they exist and are > 0
            if ((p.registered_elsewhere_count !== null && p.registered_elsewhere_count !== undefined && p.registered_elsewhere_count > 0) ||
                (p.registered_here_elsewhere_count !== null && p.registered_here_elsewhere_count !== undefined && p.registered_here_elsewhere_count > 0)) {
                html += '<div class="popup-section"><span class="popup-label">District Mismatches:</span><br>';
                if (p.registered_elsewhere_count > 0) html += '&nbsp;&nbsp;Registered elsewhere, living here: ' + escapeHtml(p.registered_elsewhere_count.toLocaleString('en-US')) + '<br>';
                if (p.registered_here_elsewhere_count > 0) html += '&nbsp;&nbsp;Registered here, living elsewhere: ' + escapeHtml(p.registered_here_elsewhere_count.toLocaleString('en-US')) + '<br>';
                html += '</div>';
            }

            return html;
        }

        async function initializeMap() {
            try {
                const votersResponse = await fetch('voters.geojson');
                const votersData = await votersResponse.json();
                let districtsData = { type: 'FeatureCollection', features: [] };
                try {
                    const districtsResponse = await fetch('districts.geojson');
                    if (districtsResponse.ok) districtsData = await districtsResponse.json();
                } catch (e) { console.log('No districts data available'); }
                let countyData = { type: 'FeatureCollection', features: [] };
                try {
                    const countyResponse = await fetch('county.geojson');
                    if (countyResponse.ok) countyData = await countyResponse.json();
                } catch (e) { console.log('No county boundary available'); }

                // Build color map from actual district IDs in data
                buildColorMap(votersData, districtsData);

                const bounds = {{ bounds }};

                // Configuration from server
                const enableClustering = {{ enable_clustering }};
                const clusterMaxZoom = {{ cluster_max_zoom }};
                const spiderfyDistanceMultiplier = {{ spiderfy_distance_multiplier }};
                const showCoverageOnHover = {{ show_coverage_on_hover }};

                // County boundary layer (outline only, no fill)
                let countyLayer = null;
                if (countyData && countyData.features && countyData.features.length > 0) {
                    countyLayer = L.geoJSON(countyData, {
                        style: function() {
                            return { weight: 4, color: '#222', fillOpacity: 0, dashArray: '10, 6', opacity: 0.9 };
                        },
                        onEachFeature: function(feature, layer) {
                            if (feature.properties.county_name) {
                                layer.bindPopup('<div class="popup-header">' + escapeHtml(feature.properties.county_name) + '</div>');
                            }
                        }
                    }).addTo(map);
                }

                let districtLayer = null;
                if (districtsData && districtsData.features && districtsData.features.length > 0) {
                    districtLayer = L.geoJSON(districtsData, {
                        style: function(feature) {
                            const c = getDistrictColor(feature.properties.district_id);
                            return { fillColor: c, weight: 2, opacity: 1, color: c, fillOpacity: 0.45 };
                        },
                        onEachFeature: function(feature, layer) { layer.bindPopup(createDistrictPopup(feature.properties)); }
                    }).addTo(map);
                }

                let voterLayer = null;
                if (votersData && votersData.features && votersData.features.length > 0) {
                    if (enableClustering) {
                        // Extract unique districts from voter data
                        const districts = new Set();
                        votersData.features.forEach(function(feature) {
                            const district = String(feature.properties.registered_district || 'unknown');
                            districts.add(district);
                        });

                        // Create separate cluster group for each district
                        const districtClusterGroups = {};
                        districts.forEach(function(district) {
                            districtClusterGroups[district] = L.markerClusterGroup({
                                maxClusterRadius: function(zoom) {
                                    // Balanced clustering: configurable via .env file
                                    if (zoom <= {{ cluster_zoom_far }}) return {{ cluster_radius_far }};
                                    if (zoom <= {{ cluster_zoom_medium }}) return {{ cluster_radius_medium }};
                                    return {{ cluster_radius_close }};
                                },
                                spiderfyDistanceMultiplier: spiderfyDistanceMultiplier,
                                showCoverageOnHover: showCoverageOnHover,
                                zoomToBoundsOnClick: true,
                                spiderfyOnMaxZoom: true,
                                removeOutsideVisibleBounds: true,
                                animate: true,
                                animateAddingMarkers: false,
                                iconCreateFunction: function(cluster) {
                                    // All markers in cluster are same district
                                    const count = cluster.getChildCount();
                                    const clusterColor = getVoterColor(district);
                                    return L.divIcon({
                                        html: '<div style="background-color:' + clusterColor + '"><span>' + count + '</span></div>',
                                        className: 'marker-cluster',
                                        iconSize: L.point(40, 40)
                                    });
                                }
                            });
                        });

                        // Group features by district (uses registered_district for map coloring)
                        const featuresByDistrict = {};
                        votersData.features.forEach(function(feature) {
                            const district = String(feature.properties.registered_district || 'unknown');
                            if (!featuresByDistrict[district]) {
                                featuresByDistrict[district] = [];
                            }
                            featuresByDistrict[district].push(feature);
                        });

                        // Create GeoJSON layer for each district and add to respective cluster group
                        const districtLayers = {};
                        Object.keys(featuresByDistrict).forEach(function(district) {
                            const districtGeoJSON = {
                                type: 'FeatureCollection',
                                features: featuresByDistrict[district]
                            };

                            const geoJsonLayer = L.geoJSON(districtGeoJSON, {
                                pointToLayer: function(feature, latlng) {
                                    return L.circleMarker(latlng, {
                                        radius: 12,
                                        fillColor: getVoterColor(district),
                                        color: '#000',
                                        weight: 1,
                                        opacity: 1,
                                        fillOpacity: 0.7
                                    });
                                },
                                onEachFeature: function(feature, layer) {
                                    layer.bindPopup(createVoterPopup(feature.properties));
                                    layer.feature = feature;
                                }
                            });

                            districtClusterGroups[district].addLayer(geoJsonLayer);
                            districtLayers[district] = districtClusterGroups[district];
                        });

                        // Add all district layers to map
                        Object.values(districtLayers).forEach(function(layer) {
                            layer.addTo(map);
                        });

                        // Store reference for layer controls (voterLayer becomes object of layers)
                        voterLayer = districtLayers;
                    } else {
                        // Original non-clustered behavior (uses registered_district for map coloring)
                        voterLayer = L.geoJSON(votersData, {
                            pointToLayer: function(feature, latlng) {
                                return L.circleMarker(latlng, { radius: 12, fillColor: getVoterColor(feature.properties.registered_district), color: '#000', weight: 1, opacity: 1, fillOpacity: 0.7 });
                            },
                            onEachFeature: function(feature, layer) { layer.bindPopup(createVoterPopup(feature.properties)); }
                        }).addTo(map);
                    }
                }

                if (bounds && bounds.length === 2) map.fitBounds(bounds, { padding: [20, 20] });
                else map.setView([0, 0], 2);

                const overlayMaps = {};

                // Handle voter layers
                if (voterLayer) {
                    if (typeof voterLayer === 'object' && !voterLayer._leaflet_id) {
                        // Multiple district layers (object with district keys)
                        const sortedDistricts = Object.keys(voterLayer).sort(function(a, b) {
                            if (a === 'unknown') return 1;
                            if (b === 'unknown') return -1;
                            return parseInt(a) - parseInt(b);
                        });

                        sortedDistricts.forEach(function(district) {
                            const layerName = district === 'unknown'
                                ? 'Voters - Unknown District'
                                : 'Voters - District ' + district;
                            overlayMaps[layerName] = voterLayer[district];
                        });
                    } else {
                        // Single layer (non-clustered or legacy fallback)
                        overlayMaps["Voters"] = voterLayer;
                    }
                }

                if (districtLayer) overlayMaps["Districts"] = districtLayer;
                if (countyLayer) overlayMaps["County Boundary"] = countyLayer;
                if (Object.keys(overlayMaps).length > 0) L.control.layers(null, overlayMaps).addTo(map);

                const info = L.control({ position: 'topleft' });
                info.onAdd = function(map) { this._div = L.DomUtil.create('div', 'info'); this.update(); return this._div; };
                info.update = function() {
                    const voterCount = votersData && votersData.features ? votersData.features.length : 0;
                    const districtCount = districtsData && districtsData.features ? districtsData.features.length : 0;
                    let html = '<h4>{{ title }}</h4><div class="count">' + voterCount.toLocaleString() + ' Voters</div>';
                    if (districtCount > 0) html += '<div>' + districtCount + ' Districts</div>';

                    // Add credits
                    html += '<div class="credit">';
                    html += '© <a href="https://www.kerryhatcher.com" target="_blank" rel="noopener noreferrer">Kerry Hatcher</a><br>';
                    html += 'Licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.en" target="_blank" rel="noopener noreferrer">CC BY-SA 4.0</a><br>';
                    html += 'Map tiles © <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener noreferrer">OpenStreetMap</a>';
                    html += '</div>';

                    this._div.innerHTML = html;
                };
                info.addTo(map);

                // Build unified district legend using normalized IDs (deduplicates "018" and "18")
                const allDistricts = new Set();
                if (districtsData && districtsData.features) {
                    districtsData.features.forEach(function(f) {
                        if (f.properties.district_id) allDistricts.add(normalizeId(f.properties.district_id));
                    });
                }
                if (votersData && votersData.features) {
                    votersData.features.forEach(function(f) {
                        if (f.properties.registered_district) allDistricts.add(normalizeId(f.properties.registered_district));
                    });
                }

                if (allDistricts.size > 0) {
                    const legend = L.control({ position: 'bottomright' });
                    legend.onAdd = function(map) {
                        const isMobile = window.innerWidth < 768;
                        const div = L.DomUtil.create('div', 'legend' + (isMobile ? ' collapsed' : ''));

                        const header = L.DomUtil.create('div', 'legend-header', div);
                        const title = L.DomUtil.create('h4', '', header);
                        title.textContent = 'District Colors';
                        const toggleBtn = L.DomUtil.create('button', 'legend-toggle', header);
                        toggleBtn.innerHTML = isMobile ? '▼' : '▲';
                        toggleBtn.setAttribute('aria-expanded', !isMobile);
                        toggleBtn.setAttribute('aria-label', 'Toggle legend');

                        const content = L.DomUtil.create('div', 'legend-content', div);

                        const sorted = Array.from(allDistricts).sort(function(a, b) {
                            if (a === 'unknown') return 1;
                            if (b === 'unknown') return -1;
                            return parseInt(a) - parseInt(b);
                        });

                        // Legend items use hardcoded color palette and escapeHtml for district IDs
                        sorted.forEach(function(district) {
                            const color = getDistrictColor(district);
                            const item = document.createElement('div');
                            const swatch = document.createElement('i');
                            swatch.style.background = color;
                            item.appendChild(swatch);
                            item.appendChild(document.createTextNode(' District ' + district));
                            item.appendChild(document.createElement('br'));
                            content.appendChild(item);
                        });

                        header.onclick = function() {
                            div.classList.toggle('collapsed');
                            const isCollapsed = div.classList.contains('collapsed');
                            toggleBtn.innerHTML = isCollapsed ? '▼' : '▲';
                            toggleBtn.setAttribute('aria-expanded', !isCollapsed);
                        };

                        return div;
                    };
                    legend.addTo(map);
                }

                document.getElementById('loading').classList.add('hidden');
            } catch (error) {
                console.error('Error loading map data:', error);
                document.getElementById('loading').innerHTML = '<div>Error loading map data: ' + escapeHtml(error.message) + '</div>';
            }
        }

        initializeMap();
    </script>
</body>
</html>
